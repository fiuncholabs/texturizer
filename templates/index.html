<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Fuzzy Skin Texturizer</title>

    <!-- Google Analytics -->
    {% if config.GA_MEASUREMENT_ID %}
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ config.GA_MEASUREMENT_ID }}"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '{{ config.GA_MEASUREMENT_ID }}');
    </script>
    {% endif %}

    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a2e1a;
            color: #eee;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #4ade80;
            margin-bottom: 10px;
        }
        .auth-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .auth-info {
            display: inline-block;
            background: #1e3e21;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            color: #aaa;
        }
        .auth-button {
            display: inline-block;
            background: #4ade80;
            color: #1a2e1a;
            padding: 8px 16px;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 500;
            transition: background 0.2s;
        }
        .auth-button:hover {
            background: #22c55e;
        }
        .auth-button.logout {
            background: #ef4444;
            color: white;
            margin-left: 10px;
        }
        .auth-button.logout:hover {
            background: #dc2626;
        }
        .user-name {
            color: #4ade80;
            font-weight: 500;
        }
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }
        .controls {
            background: #1e3e21;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        .viewer-container {
            background: #1e3e21;
            border-radius: 10px;
            overflow: hidden;
            min-height: 600px;
            position: relative;
        }
        #viewer {
            width: 100%;
            height: 600px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        input[type="number"],
        input[type="file"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #3a6b4a;
            border-radius: 5px;
            background: #0f4a30;
            color: #fff;
            font-size: 14px;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #4ade80;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #4ade80;
            color: #000;
        }
        .btn-primary:hover {
            background: #22c55e;
        }
        .btn-primary:disabled {
            background: #4a5568;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #3a6b4a;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #4a7b5a;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .file-input-btn {
            display: block;
            padding: 12px;
            background: #3a6b4a;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
        }
        .file-name {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
            word-break: break-all;
        }
        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0 10px 0;
            color: #4ade80;
            border-bottom: 1px solid #3a6b4a;
            padding-bottom: 5px;
        }
        .section-title:first-child {
            margin-top: 0;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 14px;
            display: none;
        }
        .status.error {
            background: #ff4757;
            display: block;
        }
        .status.success {
            background: #2ed573;
            color: #000;
            display: block;
        }
        .status.processing {
            background: #ffa502;
            color: #000;
            display: block;
        }
        .viewer-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            pointer-events: none;
        }
        .blocker-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(15, 74, 48, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #3a6b4a;
            display: none;
            min-width: 250px;
            max-height: calc(100% - 20px);
            overflow-y: auto;
        }
        .blocker-controls.visible {
            display: block;
        }
        .blocker-controls-title {
            margin: 0 0 12px 0;
            color: #4ade80;
            font-size: 14px;
            font-weight: 600;
        }
        .blocker-control-group {
            margin-bottom: 12px;
        }
        .blocker-control-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .blocker-control-group input[type="range"] {
            width: 100%;
            height: 4px;
            background: #0f4a30;
            border: 1px solid #3a6b4a;
            border-radius: 2px;
            outline: none;
            margin-bottom: 4px;
        }
        .blocker-control-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4ade80;
            border-radius: 50%;
            cursor: pointer;
        }
        .blocker-control-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4ade80;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .blocker-value {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #fff;
            font-family: monospace;
        }
        .info-section {
            margin-top: 15px;
            padding: 15px;
            background: #1e3e21;
            border-radius: 8px;
            border: 1px solid #3a6b4a;
        }
        .info-toggle {
            background: none;
            border: none;
            color: #4ade80;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
        }
        .info-toggle:hover {
            color: #22c55e;
        }
        .info-toggle-icon {
            transition: transform 0.2s;
        }
        .info-toggle-icon.expanded {
            transform: rotate(90deg);
        }
        .info-content {
            display: none;
            margin-top: 15px;
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
        }
        .info-content.visible {
            display: block;
        }
        .info-content h3 {
            color: #4ade80;
            font-size: 14px;
            margin: 15px 0 8px 0;
        }
        .info-content h3:first-child {
            margin-top: 0;
        }
        .info-content p {
            margin: 8px 0;
        }
        .info-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        .info-content li {
            margin: 4px 0;
        }
        .noise-options {
            display: none;
        }
        .noise-options.visible {
            display: block;
        }
        .rotation-controls {
            display: flex;
            gap: 10px;
        }
        .btn-rotate {
            flex: 1;
            padding: 8px;
            border: 1px solid #3a6b4a;
            border-radius: 5px;
            background: #0f4a30;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-rotate:hover {
            background: #1a5a3a;
        }
        /* Confirmation Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.visible {
            display: flex;
        }
        .modal-content {
            background: #1e3e21;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #3a6b4a;
        }
        .modal-title {
            font-size: 20px;
            color: #4ade80;
            margin-bottom: 20px;
            text-align: center;
        }
        .estimate-info {
            background: #0f4a30;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .estimate-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #3a6b4a;
        }
        .estimate-row:last-child {
            border-bottom: none;
        }
        .estimate-label {
            color: #aaa;
            font-size: 14px;
        }
        .estimate-value {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }
        .estimate-value.warning {
            color: #ffa502;
        }
        .estimate-value.danger {
            color: #ff4757;
        }
        .warning-message {
            background: #ffa502;
            color: #000;
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
        }
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .modal-btn-confirm {
            background: #4ade80;
            color: #000;
        }
        .modal-btn-confirm:hover {
            background: #22c55e;
        }
        .modal-btn-cancel {
            background: #3a6b4a;
            color: #fff;
        }
        .modal-btn-cancel:hover {
            background: #4a7b5a;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>STL Fuzzy Skin Texturizer</h1>

        {% if enable_google_auth %}
        <div class="auth-container">
            <div class="auth-info">
                {% if current_user.is_authenticated %}
                    <span>Signed in as <span class="user-name">{{ current_user.name }}</span></span>
                    <a href="/auth/logout" class="auth-button logout">Sign Out</a>
                {% else %}
                    <a href="/auth/login" class="auth-button">Sign in with Google</a>
                {% endif %}
            </div>
        </div>
        {% endif %}

        <div class="main-content">
            <div class="controls">
                <div id="status" class="status"></div>

                <div id="fileUploadSection">
                    <div class="form-group">
                        <div class="file-input-wrapper">
                            <div class="file-input-btn">Choose STL File</div>
                            <input type="file" id="stlFile" accept=".stl">
                        </div>
                        <div id="fileName" class="file-name">No file selected</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="useDefaultCube" checked>
                        Use default test object
                    </label>
                </div>

                <div class="section-title">Fuzzy Skin Settings</div>
                <div class="form-group">
                    <label for="noiseType">Noise Type</label>
                    <select id="noiseType">
                        {% for noise in noise_types %}
                        <option value="{{ noise }}">{{ noise.capitalize() }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="thickness">Thickness (mm)</label>
                    <input type="number" id="thickness" value="0.3" min="0.05" max="5" step="0.05">
                </div>
                <div class="form-group">
                    <label for="pointDistance">Point Distance (mm)</label>
                    <input type="number" id="pointDistance" value="0.8" min="0.1" max="5" step="0.1">
                </div>
                <div class="form-group">
                    <label for="seed">Random Seed</label>
                    <input type="number" id="seed" value="42" min="0" max="999999" step="1">
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="skipBottom" checked>
                        Skip bottom layer
                    </label>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="skipSmallTriangles" checked>
                        Triangle size optimization
                    </label>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="noiseOnEdges">
                        Noise on edges (eliminates seams)
                    </label>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="inPlaneNoise">
                        In-plane noise only (XY, like OrcaSlicer)
                    </label>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="simplifyMesh">
                        Mesh simplification
                    </label>
                </div>
                <div id="simplificationControls" style="display:none; margin-left: 20px;">
                    <div class="form-group">
                        <label>
                            Simplification (% reduction): <span id="simplificationRatioValue">50%</span>
                        </label>
                        <input type="range" id="simplificationRatio" min="10" max="90" value="50" step="5">
                    </div>
                </div>

                <div class="section-title">Blocker Volume</div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="useBlocker">
                        Use blocker volume
                    </label>
                </div>

                <div id="blockerVisibilitySection" style="display:none">
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showBlocker" checked>
                            Show blocker in viewer
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showIntersection" checked>
                            Show intersection (yellow) mesh
                        </label>
                    </div>
                </div>

                <div id="blockerSection" style="display:none">
                    <div class="form-group">
                        <label for="blockerType">Blocker Shape</label>
                        <select id="blockerType">
                            <option value="cylinder" selected>Cylinder</option>
                            <option value="cube">Cube</option>
                            <option value="custom">Custom STL</option>
                        </select>
                    </div>

                    <!-- Cylinder options -->
                    <div id="cylinderOptions">
                        <div class="form-group">
                            <label for="cylinderRadius">Cylinder Radius (mm)</label>
                            <input type="number" id="cylinderRadius" value="5" min="1" max="100" step="1">
                        </div>
                        <div class="form-group">
                            <label for="cylinderHeight">Cylinder Height (mm)</label>
                            <input type="number" id="cylinderHeight" value="25" min="1" max="200" step="1">
                        </div>
                    </div>

                    <!-- Cube options -->
                    <div id="cubeOptions" style="display:none">
                        <div class="form-group">
                            <label for="cubeWidth">Cube Width (mm)</label>
                            <input type="number" id="cubeWidth" value="10" min="1" max="200" step="1">
                        </div>
                        <div class="form-group">
                            <label for="cubeHeight">Cube Height (mm)</label>
                            <input type="number" id="cubeHeight" value="10" min="1" max="200" step="1">
                        </div>
                        <div class="form-group">
                            <label for="cubeDepth">Cube Depth (mm)</label>
                            <input type="number" id="cubeDepth" value="10" min="1" max="200" step="1">
                        </div>
                    </div>

                    <!-- Custom STL upload -->
                    <div id="blockerUploadSection" style="display:none">
                        <div class="form-group">
                            <div class="file-input-wrapper">
                                <div class="file-input-btn">Choose Blocker STL</div>
                                <input type="file" id="blockerFile" accept=".stl">
                            </div>
                            <div id="blockerFileName" class="file-name">No blocker file selected</div>
                        </div>
                        <div class="form-group">
                            <label for="blockerScale">Scale Factor</label>
                            <input type="number" id="blockerScale" value="1.0" min="0.1" max="10" step="0.1">
                            <small>Scale the custom blocker (1.0 = original size)</small>
                        </div>
                    </div>

                    <!-- Hidden inputs for position and rotation (synced with overlay sliders) -->
                    <input type="hidden" id="blockerPosX" value="0">
                    <input type="hidden" id="blockerPosY" value="0">
                    <input type="hidden" id="blockerPosZ" value="0">
                    <input type="hidden" id="blockerRotX" value="0">
                    <input type="hidden" id="blockerRotY" value="0">
                    <input type="hidden" id="blockerRotZ" value="0">

                    <!-- Always use double_stl algorithm -->
                    <input type="hidden" id="blockerAlgorithm" value="double_stl">
                </div>

                <div id="noiseOptions" class="noise-options">
                    <div class="form-group">
                        <label for="noiseScale">Noise Scale</label>
                        <input type="number" id="noiseScale" value="1.0" min="0.1" max="10" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="noiseOctaves">Octaves</label>
                        <input type="number" id="noiseOctaves" value="4" min="1" max="8" step="1">
                    </div>
                    <div class="form-group">
                        <label for="noisePersistence">Persistence</label>
                        <input type="number" id="noisePersistence" value="0.5" min="0.1" max="1" step="0.05">
                    </div>
                </div>

                {% if enable_rotation_controls %}
                <div class="section-title">Model Rotation</div>
                <div class="form-group">
                    <label>Rotate X</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('x', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('x', 90)">+90°</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Rotate Y</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('y', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('y', 90)">+90°</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Rotate Z</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('z', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('z', 90)">+90°</button>
                    </div>
                </div>
                {% endif %}

                <button id="processBtn" class="btn btn-primary">Process STL</button>
                <button id="downloadBtn" class="btn btn-primary" disabled>Download Result</button>
                <button id="resetViewBtn" class="btn btn-secondary">Reset View</button>

                <!-- Processing Statistics Panel -->
                <div class="info-section" id="processingStatsSection" style="display: none; margin-top: 15px;">
                    <button class="info-toggle" onclick="toggleProcessingStats()">
                        <span class="info-toggle-icon" id="statsIcon">▶</span>
                        <span>Processing Statistics</span>
                    </button>
                    <div class="info-content" id="processingStatsContent">
                        <div id="processingStatsDetails"></div>
                    </div>
                </div>
            </div>

            <div class="viewer-container">
                <div id="viewer"></div>
                <div class="viewer-hint">Drag to rotate, scroll to zoom</div>

                <!-- Blocker Controls Overlay -->
                <div class="blocker-controls" id="blockerControlsOverlay">
                    <div class="blocker-controls-title">Blocker Position</div>

                    <div class="blocker-control-group">
                        <label>Position X</label>
                        <input type="range" id="blockerPosXSlider" min="-200" max="200" value="0" step="1">
                        <span class="blocker-value" id="blockerPosXValue">0</span>
                    </div>

                    <div class="blocker-control-group">
                        <label>Position Y</label>
                        <input type="range" id="blockerPosYSlider" min="-200" max="200" value="0" step="1">
                        <span class="blocker-value" id="blockerPosYValue">0</span>
                    </div>

                    <div class="blocker-control-group">
                        <label>Position Z</label>
                        <input type="range" id="blockerPosZSlider" min="-200" max="200" value="0" step="1">
                        <span class="blocker-value" id="blockerPosZValue">0</span>
                    </div>

                    <div class="blocker-controls-title" style="margin-top: 15px;">Blocker Rotation</div>

                    <div class="blocker-control-group">
                        <label>Rotation X</label>
                        <input type="range" id="blockerRotXSlider" min="-180" max="180" value="0" step="15">
                        <span class="blocker-value" id="blockerRotXValue">0°</span>
                    </div>

                    <div class="blocker-control-group">
                        <label>Rotation Y</label>
                        <input type="range" id="blockerRotYSlider" min="-180" max="180" value="0" step="15">
                        <span class="blocker-value" id="blockerRotYValue">0°</span>
                    </div>

                    <div class="blocker-control-group">
                        <label>Rotation Z</label>
                        <input type="range" id="blockerRotZSlider" min="-180" max="180" value="0" step="15">
                        <span class="blocker-value" id="blockerRotZValue">0°</span>
                    </div>
                </div>

                <div class="info-section">
                    <button class="info-toggle" onclick="toggleInfo()">
                        <span class="info-toggle-icon" id="infoIcon">▶</span>
                        <span>More Info</span>
                    </button>
                    <div class="info-content" id="infoContent">
                        <h3>About This Tool <span style="color: #888; font-size: 0.9em;">({{ version }} - First Leaf)</span></h3>
                        <p>This application replicates OrcaSlicer's fuzzy skin feature by applying texture directly to STL files. The fuzzy skin effect adds a randomized surface texture that can help hide layer lines and create interesting surface finishes.</p>

                        <h3>STL vs G-code: Key Differences</h3>
                        <p>Unlike OrcaSlicer which generates fuzzy skin at the G-code level during slicing, this tool modifies the mesh geometry itself. This approach has important implications:</p>
                        <ul>
                            <li><strong>Triangle count:</strong> The output STL will have significantly more triangles than the input, as the mesh must be subdivided to achieve the texture effect. Large or detailed models may result in very large files.</li>
                            <li><strong>Processing time:</strong> Mesh subdivision is computationally intensive. Complex models may take longer to process than generating G-code.</li>
                            <li><strong>File size:</strong> The resulting STL files can be much larger than the original, which may impact slicer performance.</li>
                            <li><strong>Flexibility:</strong> Once applied, the fuzzy skin texture is permanent in the mesh and cannot be easily adjusted without reprocessing the original file.</li>
                        </ul>

                        <h3>Triangle Size Optimization</h3>
                        <p>The "Triangle size optimization" setting skips subdivision for triangles that are already smaller than the point distance parameter. This optimization:</p>
                        <ul>
                            <li>Significantly reduces processing time and output file size for detailed models</li>
                            <li>Prevents unnecessary subdivision of small details that wouldn't benefit from additional texture</li>
                            <li>May result in slightly uneven texture density on models with varying triangle sizes</li>
                            <li>Is generally recommended for most use cases, especially for complex or high-resolution meshes</li>
                        </ul>

                        <h3>Processing Limits</h3>
                        <p>To ensure reasonable processing times and prevent server overload, the following limits are enforced:</p>
                        <ul>
                            <li><strong>Maximum output triangles:</strong> 20 million triangles</li>
                            <li><strong>Maximum file size:</strong> 500 MB for the output STL file</li>
                            <li><strong>Maximum memory usage:</strong> 4 GB estimated memory consumption</li>
                        </ul>
                        <p>If your model exceeds these limits, try increasing the point distance parameter or enabling triangle size optimization. The application will provide an estimate before processing and suggest adjustments if needed.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Processing Estimate</div>
                <div id="warningMessage" class="warning-message" style="display: none;"></div>
                <div class="estimate-info">
                    <div class="estimate-row">
                        <span class="estimate-label">Input triangles:</span>
                        <span id="inputTriangles" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">Output triangles:</span>
                        <span id="outputTriangles" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">File size:</span>
                        <span id="fileSize" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">Estimated time:</span>
                        <span id="estimatedTime" class="estimate-value">-</span>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="cancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
                    <button id="confirmBtn" class="modal-btn modal-btn-confirm">Proceed</button>
                </div>
            </div>
        </div>

        {% if show_support_footer %}
        <footer style="text-align: center; margin-top: 40px; padding: 20px; color: #888; font-size: 13px;">
            <p style="margin-bottom: 10px;">
                STL Fuzzy Skin Texturizer - Open Source Project
            </p>
            <p style="margin-bottom: 10px;">
                <a href="https://github.com/your-username/texturizer" target="_blank" style="color: #4ade80; text-decoration: none;">GitHub</a>
                •
                <a href="https://ko-fi.com/igloopup" target="_blank" style="color: #4ade80; text-decoration: none;">Support on Ko-fi</a>
            </p>
            <p style="font-size: 11px; color: #666;">
                Inspired by OrcaSlicer's fuzzy skin implementation
            </p>
        </footer>
        {% endif %}
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // Google Analytics helper function
        function trackEvent(eventName, eventParams = {}) {
            if (typeof gtag !== 'undefined') {
                gtag('event', eventName, eventParams);
            }
        }

        // Three.js setup
        let scene, camera, renderer, controls, currentMesh, blockerMesh;
        let uploadedBlockerFile = null;
        let currentSplitMetadata = null;  // Track split metadata for intersection hiding
        const viewerContainer = document.getElementById('viewer');

        function initViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2e1a);

            camera = new THREE.PerspectiveCamera(
                45,
                viewerContainer.clientWidth / viewerContainer.clientHeight,
                0.1,
                10000
            );
            camera.position.set(150, 120, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid
            const grid = new THREE.GridHelper(200, 20, 0x3a6b4a, 0x2a5a3a);
            scene.add(grid);

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function loadSTL(arrayBuffer, splitMetadata = null) {
            if (currentMesh) {
                scene.remove(currentMesh);
            }

            const loader = new THREE.STLLoader();
            const geometry = loader.parse(arrayBuffer);

            // Rotate to match slicer convention (STL uses Z-up, Three.js uses Y-up)
            geometry.rotateX(-Math.PI / 2);

            // Check if we need dual-color rendering (for double_stl algorithm)
            if (splitMetadata && splitMetadata.splitIndex > 0) {
                // Create vertex colors for dual-color rendering
                const positions = geometry.attributes.position;
                const colors = new Float32Array(positions.count * 3);

                // Green for outside (processed), Yellow for inside (unprocessed)
                const greenColor = new THREE.Color(0x4ade80);  // Green
                const yellowColor = new THREE.Color(0xffd700); // Yellow/Gold

                // Each triangle has 3 vertices
                const splitIndex = splitMetadata.splitIndex;
                for (let i = 0; i < positions.count / 3; i++) {
                    const triangleIndex = i;
                    const color = triangleIndex < splitIndex ? greenColor : yellowColor;

                    // Set color for all 3 vertices of this triangle
                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = i * 3 + j;
                        colors[vertexIndex * 3] = color.r;
                        colors[vertexIndex * 3 + 1] = color.g;
                        colors[vertexIndex * 3 + 2] = color.b;
                    }
                }

                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                // Material with vertex colors
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    specular: 0x111111,
                    shininess: 200
                });

                currentMesh = new THREE.Mesh(geometry, material);

                // Store split metadata for intersection hiding
                currentSplitMetadata = splitMetadata;

                console.log(`Dual-color rendering: ${splitMetadata.outsideCount} green triangles (outside), ${splitMetadata.insideCount} yellow triangles (inside)`);
            } else {
                // Single color rendering (default green)
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4ade80,
                    specular: 0x111111,
                    shininess: 200
                });

                currentMesh = new THREE.Mesh(geometry, material);

                // Clear split metadata for non-split meshes
                currentSplitMetadata = null;
            }

            // Center horizontally and place on grid (bottom at y=0)
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const minY = geometry.boundingBox.min.y;
            currentMesh.position.set(-center.x, -minY, -center.z);

            // Adjust camera to fit model
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(maxDim * 2.5, maxDim * 2.5, maxDim * 2.5);
            controls.target.set(0, 0, 0);
            controls.update();

            scene.add(currentMesh);
        }

        function loadBlockerSTL(arrayBuffer) {
            if (blockerMesh) {
                scene.remove(blockerMesh);
            }

            const loader = new THREE.STLLoader();
            const geometry = loader.parse(arrayBuffer);

            // Apply scale factor
            const scale = parseFloat(document.getElementById('blockerScale').value);
            geometry.scale(scale, scale, scale);

            // Rotate to match slicer convention (Z-up to Y-up)
            geometry.rotateX(-Math.PI / 2);

            // Semi-transparent red material for blocker
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4757,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            blockerMesh = new THREE.Mesh(geometry, material);

            // Get position and rotation offsets
            const posX = parseFloat(document.getElementById('blockerPosX').value);
            const posY = parseFloat(document.getElementById('blockerPosY').value);
            const posZ = parseFloat(document.getElementById('blockerPosZ').value);
            const rotX = parseFloat(document.getElementById('blockerRotX').value) * Math.PI / 180;
            const rotY = parseFloat(document.getElementById('blockerRotY').value) * Math.PI / 180;
            const rotZ = parseFloat(document.getElementById('blockerRotZ').value) * Math.PI / 180;

            // Position blocker at the center of the visible mesh
            if (currentMesh && currentMesh.geometry.boundingBox) {
                const bbox = currentMesh.geometry.boundingBox;
                const meshCenter = new THREE.Vector3();
                bbox.getCenter(meshCenter);
                const worldCenter = meshCenter.clone().add(currentMesh.position);

                // Apply position offset (STL coordinates are Z-up, Three.js is Y-up)
                blockerMesh.position.set(
                    worldCenter.x + posX,
                    worldCenter.y + posZ,
                    worldCenter.z - posY
                );
            } else {
                blockerMesh.position.set(posX, posZ, -posY);
            }

            // Apply rotation (same as cylinder/cube)
            blockerMesh.rotation.set(rotX, rotZ, -rotY);

            scene.add(blockerMesh);
        }

        function toggleIntersectionVisibility(show) {
            if (!currentMesh || !currentSplitMetadata) {
                return;  // No split mesh loaded
            }

            const geometry = currentMesh.geometry;
            const colorAttribute = geometry.getAttribute('color');

            if (!colorAttribute) {
                return;  // No vertex colors
            }

            const colors = colorAttribute.array;
            const splitIndex = currentSplitMetadata.splitIndex;
            const greenColor = new THREE.Color(0x4ade80);
            const yellowColor = new THREE.Color(0xffd700);
            const transparentColor = new THREE.Color(0x000000);  // Will be made invisible

            // Update colors for yellow (inside) triangles
            for (let i = 0; i < geometry.attributes.position.count / 3; i++) {
                const triangleIndex = i;

                if (triangleIndex >= splitIndex) {
                    // This is a yellow (inside) triangle
                    const color = show ? yellowColor : greenColor;  // When hiding, make them green to blend

                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = i * 3 + j;
                        if (show) {
                            colors[vertexIndex * 3] = yellowColor.r;
                            colors[vertexIndex * 3 + 1] = yellowColor.g;
                            colors[vertexIndex * 3 + 2] = yellowColor.b;
                        } else {
                            // Make transparent by setting alpha in material
                            colors[vertexIndex * 3] = 0;
                            colors[vertexIndex * 3 + 1] = 0;
                            colors[vertexIndex * 3 + 2] = 0;
                        }
                    }
                }
            }

            colorAttribute.needsUpdate = true;

            // Enable/disable transparency in material
            currentMesh.material.transparent = !show;
            if (!show) {
                currentMesh.material.opacity = 0.99;  // Slight transparency to hide black triangles
            } else {
                currentMesh.material.opacity = 1.0;
            }
        }

        function generateDefaultCylinderPreview() {
            const radius = parseFloat(document.getElementById('cylinderRadius').value);
            const height = parseFloat(document.getElementById('cylinderHeight').value);

            // Get position and rotation offsets
            const posX = parseFloat(document.getElementById('blockerPosX').value);
            const posY = parseFloat(document.getElementById('blockerPosY').value);
            const posZ = parseFloat(document.getElementById('blockerPosZ').value);
            const rotX = parseFloat(document.getElementById('blockerRotX').value) * Math.PI / 180; // Convert to radians
            const rotY = parseFloat(document.getElementById('blockerRotY').value) * Math.PI / 180;
            const rotZ = parseFloat(document.getElementById('blockerRotZ').value) * Math.PI / 180;

            // Remove existing blocker
            if (blockerMesh) {
                scene.remove(blockerMesh);
            }

            // Create cylinder geometry in Three.js
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);

            // Semi-transparent red material
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4757,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            blockerMesh = new THREE.Mesh(geometry, material);

            // Position blocker at the center of the visible mesh
            // The backend positions the blocker at the mesh center in STL coordinates (Z-up)
            // After rotation to Y-up and centering, the blocker should be at (0, centerY, 0)
            // where centerY is the vertical center of the mesh bounds
            if (currentMesh && currentMesh.geometry.boundingBox) {
                const bbox = currentMesh.geometry.boundingBox;
                const meshCenter = new THREE.Vector3();
                bbox.getCenter(meshCenter);

                // The currentMesh is already positioned, so we need to account for that
                const worldCenter = meshCenter.clone().add(currentMesh.position);

                // Apply position offset (STL coordinates are Z-up, Three.js is Y-up)
                // STL: X=X, Y=Y, Z=Z -> Three.js: X=X, Y=Z, Z=-Y
                blockerMesh.position.set(
                    worldCenter.x + posX,
                    worldCenter.y + posZ,  // STL Z -> Three.js Y
                    worldCenter.z - posY   // STL Y -> Three.js -Z
                );
            } else {
                // Fallback: position at origin with offsets
                blockerMesh.position.set(posX, posZ, -posY);
            }

            // Apply rotation (in order: X, Y, Z)
            // Note: Three.js uses Y-up, so we need to adjust rotation axes
            // STL rotations (Z-up) need to be converted to Three.js (Y-up)
            blockerMesh.rotation.set(rotX, rotZ, -rotY);

            scene.add(blockerMesh);
        }

        function generateDefaultCubePreview() {
            const width = parseFloat(document.getElementById('cubeWidth').value);
            const height = parseFloat(document.getElementById('cubeHeight').value);
            const depth = parseFloat(document.getElementById('cubeDepth').value);

            // Get position and rotation offsets
            const posX = parseFloat(document.getElementById('blockerPosX').value);
            const posY = parseFloat(document.getElementById('blockerPosY').value);
            const posZ = parseFloat(document.getElementById('blockerPosZ').value);
            const rotX = parseFloat(document.getElementById('blockerRotX').value) * Math.PI / 180;
            const rotY = parseFloat(document.getElementById('blockerRotY').value) * Math.PI / 180;
            const rotZ = parseFloat(document.getElementById('blockerRotZ').value) * Math.PI / 180;

            // Remove existing blocker
            if (blockerMesh) {
                scene.remove(blockerMesh);
            }

            // Create box geometry in Three.js
            const geometry = new THREE.BoxGeometry(width, height, depth);

            // Semi-transparent red material
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4757,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            blockerMesh = new THREE.Mesh(geometry, material);

            // Position blocker at the center of the visible mesh
            if (currentMesh && currentMesh.geometry.boundingBox) {
                const bbox = currentMesh.geometry.boundingBox;
                const meshCenter = new THREE.Vector3();
                bbox.getCenter(meshCenter);

                const worldCenter = meshCenter.clone().add(currentMesh.position);

                // Apply position offset (STL coordinates are Z-up, Three.js is Y-up)
                blockerMesh.position.set(
                    worldCenter.x + posX,
                    worldCenter.y + posZ,
                    worldCenter.z - posY
                );
            } else {
                blockerMesh.position.set(posX, posZ, -posY);
            }

            // Apply rotation
            blockerMesh.rotation.set(rotX, rotZ, -rotY);

            scene.add(blockerMesh);
        }

        function removeBlocker() {
            if (blockerMesh) {
                scene.remove(blockerMesh);
                blockerMesh = null;
            }
        }

        function rotateModel(axis, degrees) {
            if (!currentMesh) return;

            const radians = degrees * Math.PI / 180;
            const geometry = currentMesh.geometry;

            // Rotate geometry
            if (axis === 'x') geometry.rotateX(radians);
            else if (axis === 'y') geometry.rotateY(radians);
            else if (axis === 'z') geometry.rotateZ(radians);

            // Reposition to sit on grid
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const minY = geometry.boundingBox.min.y;
            currentMesh.position.set(-center.x, -minY, -center.z);
        }

        function resetView() {
            if (currentMesh) {
                const geometry = currentMesh.geometry;
                geometry.computeBoundingBox();
                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim * 2.5, maxDim * 2.5, maxDim * 2.5);
            } else {
                camera.position.set(100, 100, 100);
            }
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function toggleInfo() {
            const content = document.getElementById('infoContent');
            const icon = document.getElementById('infoIcon');

            if (content.classList.contains('visible')) {
                content.classList.remove('visible');
                icon.classList.remove('expanded');
                icon.textContent = '▶';
            } else {
                content.classList.add('visible');
                icon.classList.add('expanded');
                icon.textContent = '▼';
            }
        }

        function toggleProcessingStats() {
            const content = document.getElementById('processingStatsContent');
            const icon = document.getElementById('statsIcon');

            if (content.classList.contains('visible')) {
                content.classList.remove('visible');
                icon.classList.remove('expanded');
                icon.textContent = '▶';
            } else {
                content.classList.add('visible');
                icon.classList.add('expanded');
                icon.textContent = '▼';
            }
        }

        function displayProcessingStats(stats) {
            const statsSection = document.getElementById('processingStatsSection');
            const statsDetails = document.getElementById('processingStatsDetails');

            let html = '<h3>Processing Summary</h3>';

            // Mesh Simplification
            if (stats.simplification) {
                html += '<h3>Mesh Simplification</h3>';
                html += '<ul>';
                html += `<li>Original triangles: <strong>${stats.simplification.original_triangles.toLocaleString()}</strong></li>`;
                html += `<li>Simplified triangles: <strong>${stats.simplification.simplified_triangles.toLocaleString()}</strong></li>`;
                html += `<li>Reduction: <strong>${stats.simplification.reduction_percent.toFixed(1)}%</strong></li>`;
                html += '</ul>';
            }

            // Triangle Optimization
            if (stats.optimization) {
                html += '<h3>Triangle Size Optimization</h3>';
                html += '<ul>';
                html += `<li>Triangles skipped (already small): <strong>${stats.optimization.skipped_triangles.toLocaleString()}</strong></li>`;
                if (stats.optimization.skipped_percent !== undefined) {
                    html += `<li>Skipped percentage: <strong>${stats.optimization.skipped_percent.toFixed(1)}%</strong></li>`;
                }
                html += '</ul>';
            }

            // File Sizes
            if (stats.file_sizes) {
                html += '<h3>File Sizes</h3>';
                html += '<ul>';
                if (stats.file_sizes.input_size_kb) {
                    html += `<li>Input STL: <strong>${stats.file_sizes.input_size_kb.toFixed(1)} KB</strong></li>`;
                }
                html += `<li>Output STL: <strong>${stats.file_sizes.output_size_kb.toFixed(1)} KB</strong></li>`;
                if (stats.file_sizes.size_increase_percent !== undefined) {
                    const sign = stats.file_sizes.size_increase_percent >= 0 ? '+' : '';
                    html += `<li>Size change: <strong>${sign}${stats.file_sizes.size_increase_percent.toFixed(1)}%</strong></li>`;
                }
                html += '</ul>';
            }

            // Processing Time
            if (stats.processing_time) {
                html += '<h3>Processing Time</h3>';
                html += '<ul>';
                html += `<li>Total time: <strong>${stats.processing_time.total_seconds.toFixed(2)} seconds</strong></li>`;
                html += '</ul>';
            }

            // Triangle Counts
            if (stats.triangles) {
                html += '<h3>Triangle Counts</h3>';
                html += '<ul>';
                html += `<li>Input mesh: <strong>${stats.triangles.input.toLocaleString()}</strong></li>`;
                html += `<li>Output mesh: <strong>${stats.triangles.output.toLocaleString()}</strong></li>`;
                html += `<li>Increase: <strong>${((stats.triangles.output / stats.triangles.input - 1) * 100).toFixed(1)}%</strong></li>`;
                html += '</ul>';
            }

            statsDetails.innerHTML = html;
            statsSection.style.display = 'block';
        }

        // UI handling
        const fileInput = document.getElementById('stlFile');
        const fileNameDisplay = document.getElementById('fileName');
        const processBtn = document.getElementById('processBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusDiv = document.getElementById('status');
        const noiseType = document.getElementById('noiseType');
        const noiseOptions = document.getElementById('noiseOptions');
        const useDefaultCube = document.getElementById('useDefaultCube');
        const fileUploadSection = document.getElementById('fileUploadSection');
        const cubeOptionsSection = document.getElementById('cubeOptionsSection');

        let uploadedFile = null;
        let processedBlob = null;
        let processedFilename = 'fuzzy_output.stl';
        let processingStartTime = null;

        // Handle default cube checkbox
        useDefaultCube.addEventListener('change', (e) => {
            if (e.target.checked) {
                processBtn.disabled = false;

                // Track default object usage
                trackEvent('default_cube_selected');

                // Generate and show default object preview
                generateDefaultObjectPreview();
            } else {
                processBtn.disabled = !uploadedFile;

                // Clear preview if no file uploaded
                if (!uploadedFile && currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh = null;
                }
            }
        });

        function generateDefaultObjectPreview() {
            const size = 20; // Fixed default object size

            // Generate the actual default object on the server and display it
            const formData = new FormData();
            formData.append('use_default_cube', 'true');
            formData.append('cube_size', size);
            formData.append('thickness', '0');  // No fuzzy skin for preview
            formData.append('point_distance', '0.8');
            formData.append('seed', '42');
            formData.append('noise_type', 'classic');
            formData.append('skip_bottom', 'false');

            // Show loading state
            setStatus('Generating preview...', 'processing');

            fetch('/api/process', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) throw new Error('Preview generation failed');
                return response.blob();
            })
            .then(blob => blob.arrayBuffer())
            .then(arrayBuffer => {
                loadSTL(arrayBuffer);
                setStatus('', '');
            })
            .catch(error => {
                console.error('Preview generation error:', error);
                // Fall back to simple box on error
                generateSimpleBoxPreview(size);
                setStatus('', '');
            });
        }

        function generateSimpleBoxPreview(size) {
            const width = size * 1.5;
            const height = size;
            const thickness = size * 0.1;
            const geometry = new THREE.BoxGeometry(width, thickness, height);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4ade80,
                specular: 0x111111,
                shininess: 200
            });

            if (currentMesh) {
                scene.remove(currentMesh);
            }

            currentMesh = new THREE.Mesh(geometry, material);
            currentMesh.position.set(0, 0, 0);
            scene.add(currentMesh);

            camera.position.set(size * 4.5, size * 3.5, size * 4.5);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadedFile = file;
                fileNameDisplay.textContent = file.name;
                processBtn.disabled = false;

                // Uncheck the default card checkbox since user uploaded a file
                useDefaultCube.checked = false;

                // Track file upload
                trackEvent('file_uploaded', {
                    file_size_category: file.size < 1024*1024 ? 'small' : file.size < 10*1024*1024 ? 'medium' : 'large'
                });

                // Load preview
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadSTL(event.target.result);

                    // Update blocker preview if blocker is enabled
                    if (useBlocker.checked && useDefaultCylinder.checked) {
                        generateDefaultCylinderPreview();
                    }
                };
                reader.readAsArrayBuffer(file);

                setStatus('', '');
            }
        });

        noiseType.addEventListener('change', () => {
            const type = noiseType.value;
            if (type === 'classic') {
                noiseOptions.classList.remove('visible');
            } else {
                noiseOptions.classList.add('visible');
            }
        });

        resetViewBtn.addEventListener('click', resetView);

        // Blocker controls event handlers
        const useBlocker = document.getElementById('useBlocker');
        const blockerSection = document.getElementById('blockerSection');
        const blockerVisibilitySection = document.getElementById('blockerVisibilitySection');
        const showBlocker = document.getElementById('showBlocker');
        const blockerType = document.getElementById('blockerType');
        const blockerUploadSection = document.getElementById('blockerUploadSection');
        const cylinderOptions = document.getElementById('cylinderOptions');
        const cubeOptions = document.getElementById('cubeOptions');
        const blockerFileInput = document.getElementById('blockerFile');
        const blockerScale = document.getElementById('blockerScale');
        const cylinderRadius = document.getElementById('cylinderRadius');
        const cylinderHeight = document.getElementById('cylinderHeight');
        const cubeWidth = document.getElementById('cubeWidth');
        const cubeHeight = document.getElementById('cubeHeight');
        const cubeDepth = document.getElementById('cubeDepth');

        useBlocker.addEventListener('change', (e) => {
            blockerSection.style.display = e.target.checked ? 'block' : 'none';
            blockerVisibilitySection.style.display = e.target.checked ? 'block' : 'none';
            if (e.target.checked) {
                updateBlockerPreview();
            } else {
                removeBlocker();
            }
        });

        showBlocker.addEventListener('change', (e) => {
            if (blockerMesh) {
                blockerMesh.visible = e.target.checked;
            }
        });

        const showIntersection = document.getElementById('showIntersection');
        showIntersection.addEventListener('change', (e) => {
            toggleIntersectionVisibility(e.target.checked);
        });

        // Handle blocker type changes
        blockerType.addEventListener('change', () => {
            updateBlockerTypeVisibility();
            updateBlockerPreview();
        });

        // Handle mesh simplification checkbox
        const simplifyMesh = document.getElementById('simplifyMesh');
        const simplificationControls = document.getElementById('simplificationControls');
        const simplificationRatio = document.getElementById('simplificationRatio');
        const simplificationRatioValue = document.getElementById('simplificationRatioValue');

        simplifyMesh.addEventListener('change', (e) => {
            simplificationControls.style.display = e.target.checked ? 'block' : 'none';
        });

        simplificationRatio.addEventListener('input', (e) => {
            simplificationRatioValue.textContent = e.target.value + '%';
        });

        function updateBlockerTypeVisibility() {
            const type = blockerType.value;
            cylinderOptions.style.display = type === 'cylinder' ? 'block' : 'none';
            cubeOptions.style.display = type === 'cube' ? 'block' : 'none';
            blockerUploadSection.style.display = type === 'custom' ? 'block' : 'none';
        }

        function updateBlockerPreview() {
            if (!useBlocker.checked) return;

            const type = blockerType.value;
            if (type === 'cylinder') {
                generateDefaultCylinderPreview();
            } else if (type === 'cube') {
                generateDefaultCubePreview();
            } else {
                // Custom - wait for file upload
                removeBlocker();
                uploadedBlockerFile = null;
            }
        }

        cylinderRadius.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'cylinder') {
                generateDefaultCylinderPreview();
            }
        });

        cylinderHeight.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'cylinder') {
                generateDefaultCylinderPreview();
            }
        });

        cubeWidth.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'cube') {
                generateDefaultCubePreview();
            }
        });

        cubeHeight.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'cube') {
                generateDefaultCubePreview();
            }
        });

        cubeDepth.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'cube') {
                generateDefaultCubePreview();
            }
        });

        // Position and rotation control event listeners
        const positionAndRotationInputs = [
            'blockerPosX', 'blockerPosY', 'blockerPosZ',
            'blockerRotX', 'blockerRotY', 'blockerRotZ'
        ];

        positionAndRotationInputs.forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if (useBlocker.checked) {
                    const type = blockerType.value;
                    if (type === 'cylinder') {
                        generateDefaultCylinderPreview();
                    } else if (type === 'cube') {
                        generateDefaultCubePreview();
                    } else if (type === 'custom' && uploadedBlockerFile) {
                        // Reload custom blocker with new position/rotation
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            loadBlockerSTL(event.target.result);
                        };
                        reader.readAsArrayBuffer(uploadedBlockerFile);
                    }
                }
            });
        });

        // Blocker controls overlay - sync sliders with sidebar inputs
        const blockerControlsOverlay = document.getElementById('blockerControlsOverlay');

        // Function to update overlay visibility
        function updateBlockerControlsVisibility() {
            const type = blockerType.value;
            if (useBlocker.checked && (type === 'cylinder' || type === 'cube' || type === 'custom')) {
                blockerControlsOverlay.classList.add('visible');
            } else {
                blockerControlsOverlay.classList.remove('visible');
            }
        }

        // Update visibility when blocker or type options change
        useBlocker.addEventListener('change', updateBlockerControlsVisibility);
        blockerType.addEventListener('change', updateBlockerControlsVisibility);

        // Sync sliders with sidebar inputs
        const sliderMappings = [
            { slider: 'blockerPosXSlider', input: 'blockerPosX', display: 'blockerPosXValue', unit: '' },
            { slider: 'blockerPosYSlider', input: 'blockerPosY', display: 'blockerPosYValue', unit: '' },
            { slider: 'blockerPosZSlider', input: 'blockerPosZ', display: 'blockerPosZValue', unit: '' },
            { slider: 'blockerRotXSlider', input: 'blockerRotX', display: 'blockerRotXValue', unit: '°' },
            { slider: 'blockerRotYSlider', input: 'blockerRotY', display: 'blockerRotYValue', unit: '°' },
            { slider: 'blockerRotZSlider', input: 'blockerRotZ', display: 'blockerRotZValue', unit: '°' }
        ];

        sliderMappings.forEach(mapping => {
            const slider = document.getElementById(mapping.slider);
            const input = document.getElementById(mapping.input);
            const display = document.getElementById(mapping.display);

            // When slider changes, update both sidebar input and display
            slider.addEventListener('input', () => {
                const value = slider.value;
                input.value = value;
                display.textContent = value + mapping.unit;

                // Trigger preview update
                if (useBlocker.checked) {
                    const type = blockerType.value;
                    if (type === 'cylinder') {
                        generateDefaultCylinderPreview();
                    } else if (type === 'cube') {
                        generateDefaultCubePreview();
                    } else if (type === 'custom' && uploadedBlockerFile) {
                        // Reload custom blocker with new position/rotation
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            loadBlockerSTL(event.target.result);
                        };
                        reader.readAsArrayBuffer(uploadedBlockerFile);
                    }
                }
            });

            // When sidebar input changes, update slider and display
            input.addEventListener('input', () => {
                const value = input.value;
                slider.value = value;
                display.textContent = value + mapping.unit;
            });

            // Initialize display values
            display.textContent = input.value + mapping.unit;
        });

        blockerFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadedBlockerFile = file;
                document.getElementById('blockerFileName').textContent = file.name;

                // Load and preview the blocker STL
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadBlockerSTL(event.target.result);
                };
                reader.readAsArrayBuffer(file);
            } else {
                uploadedBlockerFile = null;
                document.getElementById('blockerFileName').textContent = 'No blocker file selected';
                removeBlocker();
            }
        });

        // Add event listener for scale changes on custom blocker
        blockerScale.addEventListener('input', () => {
            if (useBlocker.checked && blockerType.value === 'custom' && uploadedBlockerFile) {
                // Reload the blocker with new scale
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadBlockerSTL(event.target.result);
                };
                reader.readAsArrayBuffer(uploadedBlockerFile);
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (!processedBlob) return;

            // Track download
            trackEvent('file_downloaded', {
                file_name: processedFilename
            });

            const url = URL.createObjectURL(processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = processedFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Modal elements
        const confirmModal = document.getElementById('confirmModal');
        const confirmBtn = document.getElementById('confirmBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        // Show confirmation modal with estimates
        async function showEstimate() {
            const usingDefaultCube = useDefaultCube.checked;
            if (!uploadedFile && !usingDefaultCube) return;

            processBtn.disabled = true;
            setStatus('Calculating estimate...', 'processing');

            const formData = new FormData();

            // Only append file if not using default cube
            if (!usingDefaultCube) {
                formData.append('file', uploadedFile);
            }

            formData.append('use_default_cube', usingDefaultCube);
            formData.append('cube_size', 20);
            formData.append('thickness', document.getElementById('thickness').value);
            formData.append('point_distance', document.getElementById('pointDistance').value);
            formData.append('seed', document.getElementById('seed').value);
            formData.append('noise_type', noiseType.value);
            formData.append('noise_scale', document.getElementById('noiseScale').value);
            formData.append('noise_octaves', document.getElementById('noiseOctaves').value);
            formData.append('noise_persistence', document.getElementById('noisePersistence').value);
            formData.append('skip_bottom', document.getElementById('skipBottom').checked);
            formData.append('skip_small_triangles', document.getElementById('skipSmallTriangles').checked);
            formData.append('noise_on_edges', document.getElementById('noiseOnEdges').checked);
            formData.append('in_plane_noise', document.getElementById('inPlaneNoise').checked);

            // Mesh simplification parameters
            formData.append('simplify_mesh', document.getElementById('simplifyMesh').checked);
            formData.append('simplification_ratio', document.getElementById('simplificationRatio').value / 100);

            try {
                const response = await fetch('/api/estimate', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Estimation failed');
                }

                const result = await response.json();
                const estimates = result.estimates;

                // Populate modal with estimates
                document.getElementById('inputTriangles').textContent = estimates.input_triangles.toLocaleString();

                const outputTrianglesEl = document.getElementById('outputTriangles');
                const multiplier = (estimates.estimated_triangles / estimates.input_triangles).toFixed(1);
                outputTrianglesEl.textContent = `${estimates.estimated_triangles.toLocaleString()} (~${multiplier}x)`;

                const fileSizeEl = document.getElementById('fileSize');
                if (estimates.estimated_file_size_mb >= 1000) {
                    fileSizeEl.textContent = `${(estimates.estimated_file_size_mb / 1024).toFixed(2)} GB`;
                    fileSizeEl.className = 'estimate-value danger';
                } else if (estimates.estimated_file_size_mb >= 100) {
                    fileSizeEl.textContent = `${estimates.estimated_file_size_mb.toFixed(1)} MB`;
                    fileSizeEl.className = 'estimate-value warning';
                } else {
                    fileSizeEl.textContent = `${estimates.estimated_file_size_mb.toFixed(1)} MB`;
                    fileSizeEl.className = 'estimate-value';
                }

                const estimatedTimeEl = document.getElementById('estimatedTime');
                const timeSeconds = estimates.estimated_time_seconds;
                if (timeSeconds >= 300) {
                    estimatedTimeEl.textContent = `${(timeSeconds / 60).toFixed(1)} minutes`;
                    estimatedTimeEl.className = 'estimate-value warning';
                } else if (timeSeconds >= 60) {
                    estimatedTimeEl.textContent = `${(timeSeconds / 60).toFixed(1)} minutes`;
                    estimatedTimeEl.className = 'estimate-value';
                } else {
                    estimatedTimeEl.textContent = `${timeSeconds.toFixed(1)} seconds`;
                    estimatedTimeEl.className = 'estimate-value';
                }

                // Show warning if not feasible or very large
                const warningEl = document.getElementById('warningMessage');
                if (!result.feasible) {
                    warningEl.textContent = `⚠️ ${result.reason}`;
                    warningEl.style.display = 'block';
                } else if (estimates.estimated_triangles > 10000000) {
                    warningEl.textContent = '⚠️ This will create a very large file and may take several minutes to process.';
                    warningEl.style.display = 'block';
                } else if (estimates.estimated_file_size_mb > 500) {
                    warningEl.textContent = '⚠️ The output file will be very large and may be difficult to download.';
                    warningEl.style.display = 'block';
                } else {
                    warningEl.style.display = 'none';
                }

                // Show modal
                confirmModal.classList.add('visible');
                setStatus('', '');
            } catch (error) {
                setStatus('Error: ' + error.message, 'error');
                processBtn.disabled = false;
            }
        }

        // Process the STL file
        async function processSTL() {
            const usingDefaultCube = useDefaultCube.checked;

            processingStartTime = performance.now();
            setStatus('Processing... This may take a moment.', 'processing');

            // Track processing started
            const noiseTypeValue = noiseType.value;
            trackEvent('processing_started', {
                input_type: usingDefaultCube ? 'cube' : 'file',
                noise_type: noiseTypeValue
            });

            const formData = new FormData();

            // Only append file if not using default cube
            if (!usingDefaultCube) {
                formData.append('file', uploadedFile);
            }

            formData.append('use_default_cube', usingDefaultCube);
            formData.append('cube_size', 20);
            formData.append('thickness', document.getElementById('thickness').value);
            formData.append('point_distance', document.getElementById('pointDistance').value);
            formData.append('seed', document.getElementById('seed').value);
            formData.append('noise_type', noiseType.value);
            formData.append('noise_scale', document.getElementById('noiseScale').value);
            formData.append('noise_octaves', document.getElementById('noiseOctaves').value);
            formData.append('noise_persistence', document.getElementById('noisePersistence').value);
            formData.append('skip_bottom', document.getElementById('skipBottom').checked);
            formData.append('skip_small_triangles', document.getElementById('skipSmallTriangles').checked);
            formData.append('noise_on_edges', document.getElementById('noiseOnEdges').checked);
            formData.append('in_plane_noise', document.getElementById('inPlaneNoise').checked);

            // Mesh simplification parameters
            formData.append('simplify_mesh', document.getElementById('simplifyMesh').checked);
            formData.append('simplification_ratio', document.getElementById('simplificationRatio').value / 100);

            // Blocker parameters
            if (useBlocker.checked) {
                formData.append('use_blocker', 'true');
                formData.append('blocker_algorithm', document.getElementById('blockerAlgorithm').value);

                // Position parameters
                formData.append('blocker_pos_x', document.getElementById('blockerPosX').value);
                formData.append('blocker_pos_y', document.getElementById('blockerPosY').value);
                formData.append('blocker_pos_z', document.getElementById('blockerPosZ').value);

                // Rotation parameters
                formData.append('blocker_rot_x', document.getElementById('blockerRotX').value);
                formData.append('blocker_rot_y', document.getElementById('blockerRotY').value);
                formData.append('blocker_rot_z', document.getElementById('blockerRotZ').value);

                const type = blockerType.value;
                formData.append('blocker_type', type);

                if (type === 'cylinder') {
                    formData.append('cylinder_radius', cylinderRadius.value);
                    formData.append('cylinder_height', cylinderHeight.value);
                } else if (type === 'cube') {
                    formData.append('cube_width', cubeWidth.value);
                    formData.append('cube_height', cubeHeight.value);
                    formData.append('cube_depth', cubeDepth.value);
                } else if (type === 'custom' && uploadedBlockerFile) {
                    formData.append('blocker_file', uploadedBlockerFile);
                    formData.append('blocker_scale', blockerScale.value);
                }
            }

            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    // Check if response is JSON or HTML
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        const error = await response.json();
                        throw new Error(error.error || 'Processing failed');
                    } else {
                        // Server returned HTML (error page, timeout, or crash)
                        const text = await response.text();
                        if (response.status === 504 || response.status === 502) {
                            throw new Error('Server timeout - try using a larger point distance value or smaller file');
                        } else if (response.status === 500) {
                            throw new Error('Server error - the model may be too complex. Try a larger point distance.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }
                }

                // Get filename from Content-Disposition header
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = 'fuzzy_output.stl';
                if (contentDisposition) {
                    const match = contentDisposition.match(/filename=(.+)/);
                    if (match) filename = match[1];
                }

                // Store the result
                processedBlob = await response.blob();
                processedFilename = filename;

                // Extract split metadata if using double_stl algorithm
                let splitMetadata = null;
                const splitIndex = response.headers.get('X-Split-Index');
                const outsideCount = response.headers.get('X-Outside-Count');
                const insideCount = response.headers.get('X-Inside-Count');

                if (splitIndex && outsideCount && insideCount) {
                    splitMetadata = {
                        splitIndex: parseInt(splitIndex),
                        outsideCount: parseInt(outsideCount),
                        insideCount: parseInt(insideCount)
                    };
                    console.log('Double STL metadata:', splitMetadata);
                }

                // Extract and display processing statistics
                const statsHeader = response.headers.get('X-Processing-Stats');
                if (statsHeader) {
                    try {
                        const rawStats = JSON.parse(statsHeader);
                        console.log('Raw processing stats:', rawStats);

                        // Format statistics for display
                        const stats = {};

                        // Mesh simplification stats
                        if (rawStats.simplification) {
                            stats.simplification = rawStats.simplification;
                        }

                        // Triangle optimization stats
                        if (rawStats.skipped_triangles !== undefined) {
                            const inputCount = rawStats.input_triangles || rawStats.output_triangles;
                            stats.optimization = {
                                skipped_triangles: rawStats.skipped_triangles,
                                skipped_percent: inputCount ? (rawStats.skipped_triangles / inputCount * 100) : 0
                            };
                        }

                        // File sizes
                        if (rawStats.output_size_kb) {
                            stats.file_sizes = {
                                output_size_kb: rawStats.output_size_kb
                            };
                            if (rawStats.input_size_kb) {
                                stats.file_sizes.input_size_kb = rawStats.input_size_kb;
                                stats.file_sizes.size_increase_percent =
                                    ((rawStats.output_size_kb - rawStats.input_size_kb) / rawStats.input_size_kb) * 100;
                            }
                        }

                        // Processing time
                        if (rawStats.processing_time_seconds !== undefined) {
                            stats.processing_time = {
                                total_seconds: rawStats.processing_time_seconds
                            };
                        }

                        // Triangle counts
                        if (rawStats.input_triangles && rawStats.output_triangles) {
                            stats.triangles = {
                                input: rawStats.input_triangles,
                                output: rawStats.output_triangles
                            };
                        }

                        // Display the statistics panel
                        displayProcessingStats(stats);
                    } catch (e) {
                        console.error('Failed to parse processing stats:', e);
                    }
                }

                // Load processed model in viewer with dual-color support
                const arrayBuffer = await processedBlob.arrayBuffer();
                loadSTL(arrayBuffer, splitMetadata);

                // Enable download button
                downloadBtn.disabled = false;

                // Calculate processing time
                const processingTime = ((performance.now() - processingStartTime) / 1000).toFixed(2);
                setStatus(`Processing complete in ${processingTime}s! Click Download to save.`, 'success');

                // Track successful processing
                trackEvent('processing_success', {
                    input_type: usingDefaultCube ? 'cube' : 'file',
                    noise_type: noiseTypeValue,
                    processing_time: processingTime
                });
            } catch (error) {
                setStatus('Error: ' + error.message, 'error');

                // Track processing error
                trackEvent('processing_error', {
                    input_type: usingDefaultCube ? 'cube' : 'file',
                    noise_type: noiseTypeValue,
                    error_message: error.message
                });
            } finally {
                processBtn.disabled = false;
            }
        }

        // Process button shows estimate first
        processBtn.addEventListener('click', showEstimate);

        // Confirm button starts actual processing
        confirmBtn.addEventListener('click', () => {
            confirmModal.classList.remove('visible');
            processSTL();
        });

        // Cancel button closes modal
        cancelBtn.addEventListener('click', () => {
            confirmModal.classList.remove('visible');
            processBtn.disabled = false;
        });

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (type) {
                statusDiv.classList.add(type);
            }
        }

        // Initialize
        initViewer();

        // Load default object on page load
        if (useDefaultCube.checked) {
            generateDefaultObjectPreview();
        }
    </script>
</body>
</html>
