<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Fuzzy Skin Texturizer</title>

    <!-- Google Analytics -->
    {% if config.GA_MEASUREMENT_ID %}
    <script async src="https://www.googletagmanager.com/gtag/js?id={{ config.GA_MEASUREMENT_ID }}"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', '{{ config.GA_MEASUREMENT_ID }}');
    </script>
    {% endif %}

    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a2e1a;
            color: #eee;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #4ade80;
            margin-bottom: 10px;
        }
        .auth-container {
            text-align: center;
            margin-bottom: 20px;
        }
        .auth-info {
            display: inline-block;
            background: #1e3e21;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            color: #aaa;
        }
        .auth-button {
            display: inline-block;
            background: #4ade80;
            color: #1a2e1a;
            padding: 8px 16px;
            border-radius: 5px;
            text-decoration: none;
            font-weight: 500;
            transition: background 0.2s;
        }
        .auth-button:hover {
            background: #22c55e;
        }
        .auth-button.logout {
            background: #ef4444;
            color: white;
            margin-left: 10px;
        }
        .auth-button.logout:hover {
            background: #dc2626;
        }
        .user-name {
            color: #4ade80;
            font-weight: 500;
        }
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }
        .controls {
            background: #1e3e21;
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }
        .viewer-container {
            background: #1e3e21;
            border-radius: 10px;
            overflow: hidden;
            min-height: 600px;
            position: relative;
        }
        #viewer {
            width: 100%;
            height: 600px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        input[type="number"],
        input[type="file"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #3a6b4a;
            border-radius: 5px;
            background: #0f4a30;
            color: #fff;
            font-size: 14px;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #4ade80;
        }
        input[type="checkbox"] {
            margin-right: 8px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #4ade80;
            color: #000;
        }
        .btn-primary:hover {
            background: #22c55e;
        }
        .btn-primary:disabled {
            background: #4a5568;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #3a6b4a;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #4a7b5a;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .file-input-btn {
            display: block;
            padding: 12px;
            background: #3a6b4a;
            color: #fff;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
        }
        .file-name {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
            word-break: break-all;
        }
        .section-title {
            font-size: 16px;
            font-weight: 600;
            margin: 20px 0 10px 0;
            color: #4ade80;
            border-bottom: 1px solid #3a6b4a;
            padding-bottom: 5px;
        }
        .section-title:first-child {
            margin-top: 0;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 14px;
            display: none;
        }
        .status.error {
            background: #ff4757;
            display: block;
        }
        .status.success {
            background: #2ed573;
            color: #000;
            display: block;
        }
        .status.processing {
            background: #ffa502;
            color: #000;
            display: block;
        }
        .viewer-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            pointer-events: none;
        }
        .info-section {
            margin-top: 15px;
            padding: 15px;
            background: #1e3e21;
            border-radius: 8px;
            border: 1px solid #3a6b4a;
        }
        .info-toggle {
            background: none;
            border: none;
            color: #4ade80;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
        }
        .info-toggle:hover {
            color: #22c55e;
        }
        .info-toggle-icon {
            transition: transform 0.2s;
        }
        .info-toggle-icon.expanded {
            transform: rotate(90deg);
        }
        .info-content {
            display: none;
            margin-top: 15px;
            font-size: 13px;
            line-height: 1.6;
            color: #ccc;
        }
        .info-content.visible {
            display: block;
        }
        .info-content h3 {
            color: #4ade80;
            font-size: 14px;
            margin: 15px 0 8px 0;
        }
        .info-content h3:first-child {
            margin-top: 0;
        }
        .info-content p {
            margin: 8px 0;
        }
        .info-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }
        .info-content li {
            margin: 4px 0;
        }
        .noise-options {
            display: none;
        }
        .noise-options.visible {
            display: block;
        }
        .rotation-controls {
            display: flex;
            gap: 10px;
        }
        .btn-rotate {
            flex: 1;
            padding: 8px;
            border: 1px solid #3a6b4a;
            border-radius: 5px;
            background: #0f4a30;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-rotate:hover {
            background: #1a5a3a;
        }
        /* Confirmation Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal.visible {
            display: flex;
        }
        .modal-content {
            background: #1e3e21;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            border: 2px solid #3a6b4a;
        }
        .modal-title {
            font-size: 20px;
            color: #4ade80;
            margin-bottom: 20px;
            text-align: center;
        }
        .estimate-info {
            background: #0f4a30;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .estimate-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #3a6b4a;
        }
        .estimate-row:last-child {
            border-bottom: none;
        }
        .estimate-label {
            color: #aaa;
            font-size: 14px;
        }
        .estimate-value {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }
        .estimate-value.warning {
            color: #ffa502;
        }
        .estimate-value.danger {
            color: #ff4757;
        }
        .warning-message {
            background: #ffa502;
            color: #000;
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 600;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
        }
        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .modal-btn-confirm {
            background: #4ade80;
            color: #000;
        }
        .modal-btn-confirm:hover {
            background: #22c55e;
        }
        .modal-btn-cancel {
            background: #3a6b4a;
            color: #fff;
        }
        .modal-btn-cancel:hover {
            background: #4a7b5a;
        }
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>STL Fuzzy Skin Texturizer</h1>

        {% if enable_google_auth %}
        <div class="auth-container">
            <div class="auth-info">
                {% if current_user.is_authenticated %}
                    <span>Signed in as <span class="user-name">{{ current_user.name }}</span></span>
                    <a href="/auth/logout" class="auth-button logout">Sign Out</a>
                {% else %}
                    <a href="/auth/login" class="auth-button">Sign in with Google</a>
                {% endif %}
            </div>
        </div>
        {% endif %}

        <div class="main-content">
            <div class="controls">
                <div id="status" class="status"></div>

                <div id="fileUploadSection">
                    <div class="form-group">
                        <div class="file-input-wrapper">
                            <div class="file-input-btn">Choose STL File</div>
                            <input type="file" id="stlFile" accept=".stl">
                        </div>
                        <div id="fileName" class="file-name">No file selected</div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="useDefaultCube" checked>
                        Use default test object
                    </label>
                </div>

                <div class="section-title">Fuzzy Skin Settings</div>
                <div class="form-group">
                    <label for="noiseType">Noise Type</label>
                    <select id="noiseType">
                        {% for noise in noise_types %}
                        <option value="{{ noise }}">{{ noise.capitalize() }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group">
                    <label for="thickness">Thickness (mm)</label>
                    <input type="number" id="thickness" value="0.3" min="0.05" max="5" step="0.05">
                </div>
                <div class="form-group">
                    <label for="pointDistance">Point Distance (mm)</label>
                    <input type="number" id="pointDistance" value="0.8" min="0.1" max="5" step="0.1">
                </div>
                <div class="form-group">
                    <label for="seed">Random Seed</label>
                    <input type="number" id="seed" value="42" min="0" max="999999" step="1">
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="skipBottom" checked>
                        Skip bottom layer
                    </label>
                </div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="skipSmallTriangles" checked>
                        Triangle size optimization
                    </label>
                </div>

                <div class="section-title">Blocker Volume</div>
                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="useBlocker">
                        Use blocker volume
                    </label>
                </div>

                <div id="blockerVisibilitySection" style="display:none">
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showBlocker" checked>
                            Show blocker in viewer
                        </label>
                    </div>
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showIntersection" checked>
                            Show intersection (yellow) mesh
                        </label>
                    </div>
                </div>

                <div id="blockerSection" style="display:none">
                    <div class="form-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="useDefaultCylinder" checked>
                            Use default cylinder
                        </label>
                    </div>

                    <div id="blockerUploadSection" style="display:none">
                        <div class="form-group">
                            <div class="file-input-wrapper">
                                <div class="file-input-btn">Choose Blocker STL</div>
                                <input type="file" id="blockerFile" accept=".stl">
                            </div>
                            <div id="blockerFileName" class="file-name">No blocker file selected</div>
                        </div>
                    </div>

                    <div id="cylinderOptions">
                        <div class="form-group">
                            <label for="cylinderRadius">Cylinder Radius (mm)</label>
                            <input type="number" id="cylinderRadius" value="5" min="1" max="100" step="1">
                        </div>
                        <div class="form-group">
                            <label for="cylinderHeight">Cylinder Height (mm)</label>
                            <input type="number" id="cylinderHeight" value="25" min="1" max="200" step="1">
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="blockerAlgorithm">Detection Algorithm</label>
                        <select id="blockerAlgorithm">
                            <option value="double_stl" selected>Double STL (Fast & Accurate)</option>
                            <option value="bounding_box">Bounding Box (Fast)</option>
                            <option value="bounding_sphere">Bounding Sphere (Fast)</option>
                            <option value="bounding_cylinder">Bounding Cylinder (Fast)</option>
                            <option value="ray_casting">Ray Casting (Slow)</option>
                        </select>
                    </div>
                </div>

                <div id="noiseOptions" class="noise-options">
                    <div class="form-group">
                        <label for="noiseScale">Noise Scale</label>
                        <input type="number" id="noiseScale" value="1.0" min="0.1" max="10" step="0.1">
                    </div>
                    <div class="form-group">
                        <label for="noiseOctaves">Octaves</label>
                        <input type="number" id="noiseOctaves" value="4" min="1" max="8" step="1">
                    </div>
                    <div class="form-group">
                        <label for="noisePersistence">Persistence</label>
                        <input type="number" id="noisePersistence" value="0.5" min="0.1" max="1" step="0.05">
                    </div>
                </div>

                {% if enable_rotation_controls %}
                <div class="section-title">Model Rotation</div>
                <div class="form-group">
                    <label>Rotate X</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('x', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('x', 90)">+90°</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Rotate Y</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('y', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('y', 90)">+90°</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Rotate Z</label>
                    <div class="rotation-controls">
                        <button class="btn-rotate" onclick="rotateModel('z', -90)">-90°</button>
                        <button class="btn-rotate" onclick="rotateModel('z', 90)">+90°</button>
                    </div>
                </div>
                {% endif %}

                <button id="processBtn" class="btn btn-primary">Process STL</button>
                <button id="downloadBtn" class="btn btn-primary" disabled>Download Result</button>
                <button id="resetViewBtn" class="btn btn-secondary">Reset View</button>
            </div>

            <div class="viewer-container">
                <div id="viewer"></div>
                <div class="viewer-hint">Drag to rotate, scroll to zoom</div>

                <div class="info-section">
                    <button class="info-toggle" onclick="toggleInfo()">
                        <span class="info-toggle-icon" id="infoIcon">▶</span>
                        <span>More Info</span>
                    </button>
                    <div class="info-content" id="infoContent">
                        <h3>About This Tool <span style="color: #888; font-size: 0.9em;">({{ version }} - First Leaf)</span></h3>
                        <p>This application replicates OrcaSlicer's fuzzy skin feature by applying texture directly to STL files. The fuzzy skin effect adds a randomized surface texture that can help hide layer lines and create interesting surface finishes.</p>

                        <h3>STL vs G-code: Key Differences</h3>
                        <p>Unlike OrcaSlicer which generates fuzzy skin at the G-code level during slicing, this tool modifies the mesh geometry itself. This approach has important implications:</p>
                        <ul>
                            <li><strong>Triangle count:</strong> The output STL will have significantly more triangles than the input, as the mesh must be subdivided to achieve the texture effect. Large or detailed models may result in very large files.</li>
                            <li><strong>Processing time:</strong> Mesh subdivision is computationally intensive. Complex models may take longer to process than generating G-code.</li>
                            <li><strong>File size:</strong> The resulting STL files can be much larger than the original, which may impact slicer performance.</li>
                            <li><strong>Flexibility:</strong> Once applied, the fuzzy skin texture is permanent in the mesh and cannot be easily adjusted without reprocessing the original file.</li>
                        </ul>

                        <h3>Triangle Size Optimization</h3>
                        <p>The "Triangle size optimization" setting skips subdivision for triangles that are already smaller than the point distance parameter. This optimization:</p>
                        <ul>
                            <li>Significantly reduces processing time and output file size for detailed models</li>
                            <li>Prevents unnecessary subdivision of small details that wouldn't benefit from additional texture</li>
                            <li>May result in slightly uneven texture density on models with varying triangle sizes</li>
                            <li>Is generally recommended for most use cases, especially for complex or high-resolution meshes</li>
                        </ul>

                        <h3>Processing Limits</h3>
                        <p>To ensure reasonable processing times and prevent server overload, the following limits are enforced:</p>
                        <ul>
                            <li><strong>Maximum output triangles:</strong> 20 million triangles</li>
                            <li><strong>Maximum file size:</strong> 500 MB for the output STL file</li>
                            <li><strong>Maximum memory usage:</strong> 4 GB estimated memory consumption</li>
                        </ul>
                        <p>If your model exceeds these limits, try increasing the point distance parameter or enabling triangle size optimization. The application will provide an estimate before processing and suggest adjustments if needed.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Processing Estimate</div>
                <div id="warningMessage" class="warning-message" style="display: none;"></div>
                <div class="estimate-info">
                    <div class="estimate-row">
                        <span class="estimate-label">Input triangles:</span>
                        <span id="inputTriangles" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">Output triangles:</span>
                        <span id="outputTriangles" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">File size:</span>
                        <span id="fileSize" class="estimate-value">-</span>
                    </div>
                    <div class="estimate-row">
                        <span class="estimate-label">Estimated time:</span>
                        <span id="estimatedTime" class="estimate-value">-</span>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="cancelBtn" class="modal-btn modal-btn-cancel">Cancel</button>
                    <button id="confirmBtn" class="modal-btn modal-btn-confirm">Proceed</button>
                </div>
            </div>
        </div>

        {% if show_support_footer %}
        <footer style="text-align: center; margin-top: 40px; padding: 20px; color: #888; font-size: 13px;">
            <p style="margin-bottom: 10px;">
                STL Fuzzy Skin Texturizer - Open Source Project
            </p>
            <p style="margin-bottom: 10px;">
                <a href="https://github.com/your-username/texturizer" target="_blank" style="color: #4ade80; text-decoration: none;">GitHub</a>
                •
                <a href="https://ko-fi.com/igloopup" target="_blank" style="color: #4ade80; text-decoration: none;">Support on Ko-fi</a>
            </p>
            <p style="font-size: 11px; color: #666;">
                Inspired by OrcaSlicer's fuzzy skin implementation
            </p>
        </footer>
        {% endif %}
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>

    <script>
        // Google Analytics helper function
        function trackEvent(eventName, eventParams = {}) {
            if (typeof gtag !== 'undefined') {
                gtag('event', eventName, eventParams);
            }
        }

        // Three.js setup
        let scene, camera, renderer, controls, currentMesh, blockerMesh;
        let uploadedBlockerFile = null;
        let currentSplitMetadata = null;  // Track split metadata for intersection hiding
        const viewerContainer = document.getElementById('viewer');

        function initViewer() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a2e1a);

            camera = new THREE.PerspectiveCamera(
                45,
                viewerContainer.clientWidth / viewerContainer.clientHeight,
                0.1,
                10000
            );
            camera.position.set(150, 120, 150);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
            viewerContainer.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid
            const grid = new THREE.GridHelper(200, 20, 0x3a6b4a, 0x2a5a3a);
            scene.add(grid);

            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = viewerContainer.clientWidth / viewerContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewerContainer.clientWidth, viewerContainer.clientHeight);
        }

        function loadSTL(arrayBuffer, splitMetadata = null) {
            if (currentMesh) {
                scene.remove(currentMesh);
            }

            const loader = new THREE.STLLoader();
            const geometry = loader.parse(arrayBuffer);

            // Rotate to match slicer convention (STL uses Z-up, Three.js uses Y-up)
            geometry.rotateX(-Math.PI / 2);

            // Check if we need dual-color rendering (for double_stl algorithm)
            if (splitMetadata && splitMetadata.splitIndex > 0) {
                // Create vertex colors for dual-color rendering
                const positions = geometry.attributes.position;
                const colors = new Float32Array(positions.count * 3);

                // Green for outside (processed), Yellow for inside (unprocessed)
                const greenColor = new THREE.Color(0x4ade80);  // Green
                const yellowColor = new THREE.Color(0xffd700); // Yellow/Gold

                // Each triangle has 3 vertices
                const splitIndex = splitMetadata.splitIndex;
                for (let i = 0; i < positions.count / 3; i++) {
                    const triangleIndex = i;
                    const color = triangleIndex < splitIndex ? greenColor : yellowColor;

                    // Set color for all 3 vertices of this triangle
                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = i * 3 + j;
                        colors[vertexIndex * 3] = color.r;
                        colors[vertexIndex * 3 + 1] = color.g;
                        colors[vertexIndex * 3 + 2] = color.b;
                    }
                }

                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                // Material with vertex colors
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    specular: 0x111111,
                    shininess: 200
                });

                currentMesh = new THREE.Mesh(geometry, material);

                // Store split metadata for intersection hiding
                currentSplitMetadata = splitMetadata;

                console.log(`Dual-color rendering: ${splitMetadata.outsideCount} green triangles (outside), ${splitMetadata.insideCount} yellow triangles (inside)`);
            } else {
                // Single color rendering (default green)
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4ade80,
                    specular: 0x111111,
                    shininess: 200
                });

                currentMesh = new THREE.Mesh(geometry, material);

                // Clear split metadata for non-split meshes
                currentSplitMetadata = null;
            }

            // Center horizontally and place on grid (bottom at y=0)
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const minY = geometry.boundingBox.min.y;
            currentMesh.position.set(-center.x, -minY, -center.z);

            // Adjust camera to fit model
            const size = new THREE.Vector3();
            geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(maxDim * 2.5, maxDim * 2.5, maxDim * 2.5);
            controls.target.set(0, 0, 0);
            controls.update();

            scene.add(currentMesh);
        }

        function loadBlockerSTL(arrayBuffer) {
            if (blockerMesh) {
                scene.remove(blockerMesh);
            }

            const loader = new THREE.STLLoader();
            const geometry = loader.parse(arrayBuffer);

            // Semi-transparent red material for blocker
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4757,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            blockerMesh = new THREE.Mesh(geometry, material);

            // Rotate to match slicer convention
            geometry.rotateX(-Math.PI / 2);

            // Center on grid
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const minY = geometry.boundingBox.min.y;
            blockerMesh.position.set(-center.x, -minY, -center.z);

            scene.add(blockerMesh);
        }

        function toggleIntersectionVisibility(show) {
            if (!currentMesh || !currentSplitMetadata) {
                return;  // No split mesh loaded
            }

            const geometry = currentMesh.geometry;
            const colorAttribute = geometry.getAttribute('color');

            if (!colorAttribute) {
                return;  // No vertex colors
            }

            const colors = colorAttribute.array;
            const splitIndex = currentSplitMetadata.splitIndex;
            const greenColor = new THREE.Color(0x4ade80);
            const yellowColor = new THREE.Color(0xffd700);
            const transparentColor = new THREE.Color(0x000000);  // Will be made invisible

            // Update colors for yellow (inside) triangles
            for (let i = 0; i < geometry.attributes.position.count / 3; i++) {
                const triangleIndex = i;

                if (triangleIndex >= splitIndex) {
                    // This is a yellow (inside) triangle
                    const color = show ? yellowColor : greenColor;  // When hiding, make them green to blend

                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = i * 3 + j;
                        if (show) {
                            colors[vertexIndex * 3] = yellowColor.r;
                            colors[vertexIndex * 3 + 1] = yellowColor.g;
                            colors[vertexIndex * 3 + 2] = yellowColor.b;
                        } else {
                            // Make transparent by setting alpha in material
                            colors[vertexIndex * 3] = 0;
                            colors[vertexIndex * 3 + 1] = 0;
                            colors[vertexIndex * 3 + 2] = 0;
                        }
                    }
                }
            }

            colorAttribute.needsUpdate = true;

            // Enable/disable transparency in material
            currentMesh.material.transparent = !show;
            if (!show) {
                currentMesh.material.opacity = 0.99;  // Slight transparency to hide black triangles
            } else {
                currentMesh.material.opacity = 1.0;
            }
        }

        function generateDefaultCylinderPreview() {
            const radius = parseFloat(document.getElementById('cylinderRadius').value);
            const height = parseFloat(document.getElementById('cylinderHeight').value);

            // Remove existing blocker
            if (blockerMesh) {
                scene.remove(blockerMesh);
            }

            // Create cylinder geometry in Three.js
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);

            // Semi-transparent red material
            const material = new THREE.MeshPhongMaterial({
                color: 0xff4757,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            blockerMesh = new THREE.Mesh(geometry, material);

            // Position blocker at the center of the visible mesh
            // The backend positions the blocker at the mesh center in STL coordinates (Z-up)
            // After rotation to Y-up and centering, the blocker should be at (0, centerY, 0)
            // where centerY is the vertical center of the mesh bounds
            if (currentMesh && currentMesh.geometry.boundingBox) {
                const bbox = currentMesh.geometry.boundingBox;
                const meshCenter = new THREE.Vector3();
                bbox.getCenter(meshCenter);

                // The currentMesh is already positioned, so we need to account for that
                const worldCenter = meshCenter.clone().add(currentMesh.position);

                // Position blocker at the center
                blockerMesh.position.copy(worldCenter);
            } else {
                // Fallback: position at origin with height offset
                blockerMesh.position.set(0, height / 2, 0);
            }

            scene.add(blockerMesh);
        }

        function removeBlocker() {
            if (blockerMesh) {
                scene.remove(blockerMesh);
                blockerMesh = null;
            }
        }

        function rotateModel(axis, degrees) {
            if (!currentMesh) return;

            const radians = degrees * Math.PI / 180;
            const geometry = currentMesh.geometry;

            // Rotate geometry
            if (axis === 'x') geometry.rotateX(radians);
            else if (axis === 'y') geometry.rotateY(radians);
            else if (axis === 'z') geometry.rotateZ(radians);

            // Reposition to sit on grid
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            const minY = geometry.boundingBox.min.y;
            currentMesh.position.set(-center.x, -minY, -center.z);
        }

        function resetView() {
            if (currentMesh) {
                const geometry = currentMesh.geometry;
                geometry.computeBoundingBox();
                const size = new THREE.Vector3();
                geometry.boundingBox.getSize(size);
                const maxDim = Math.max(size.x, size.y, size.z);
                camera.position.set(maxDim * 2.5, maxDim * 2.5, maxDim * 2.5);
            } else {
                camera.position.set(100, 100, 100);
            }
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function toggleInfo() {
            const content = document.getElementById('infoContent');
            const icon = document.getElementById('infoIcon');

            if (content.classList.contains('visible')) {
                content.classList.remove('visible');
                icon.classList.remove('expanded');
                icon.textContent = '▶';
            } else {
                content.classList.add('visible');
                icon.classList.add('expanded');
                icon.textContent = '▼';
            }
        }

        // UI handling
        const fileInput = document.getElementById('stlFile');
        const fileNameDisplay = document.getElementById('fileName');
        const processBtn = document.getElementById('processBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusDiv = document.getElementById('status');
        const noiseType = document.getElementById('noiseType');
        const noiseOptions = document.getElementById('noiseOptions');
        const useDefaultCube = document.getElementById('useDefaultCube');
        const fileUploadSection = document.getElementById('fileUploadSection');
        const cubeOptionsSection = document.getElementById('cubeOptionsSection');

        let uploadedFile = null;
        let processedBlob = null;
        let processedFilename = 'fuzzy_output.stl';
        let processingStartTime = null;

        // Handle default cube checkbox
        useDefaultCube.addEventListener('change', (e) => {
            if (e.target.checked) {
                processBtn.disabled = false;

                // Track default object usage
                trackEvent('default_cube_selected');

                // Generate and show default object preview
                generateDefaultObjectPreview();
            } else {
                processBtn.disabled = !uploadedFile;

                // Clear preview if no file uploaded
                if (!uploadedFile && currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh = null;
                }
            }
        });

        function generateDefaultObjectPreview() {
            const size = 20; // Fixed default object size

            // Generate the actual default object on the server and display it
            const formData = new FormData();
            formData.append('use_default_cube', 'true');
            formData.append('cube_size', size);
            formData.append('thickness', '0');  // No fuzzy skin for preview
            formData.append('point_distance', '0.8');
            formData.append('seed', '42');
            formData.append('noise_type', 'classic');
            formData.append('skip_bottom', 'false');

            // Show loading state
            setStatus('Generating preview...', 'processing');

            fetch('/api/process', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) throw new Error('Preview generation failed');
                return response.blob();
            })
            .then(blob => blob.arrayBuffer())
            .then(arrayBuffer => {
                loadSTL(arrayBuffer);
                setStatus('', '');
            })
            .catch(error => {
                console.error('Preview generation error:', error);
                // Fall back to simple box on error
                generateSimpleBoxPreview(size);
                setStatus('', '');
            });
        }

        function generateSimpleBoxPreview(size) {
            const width = size * 1.5;
            const height = size;
            const thickness = size * 0.1;
            const geometry = new THREE.BoxGeometry(width, thickness, height);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4ade80,
                specular: 0x111111,
                shininess: 200
            });

            if (currentMesh) {
                scene.remove(currentMesh);
            }

            currentMesh = new THREE.Mesh(geometry, material);
            currentMesh.position.set(0, 0, 0);
            scene.add(currentMesh);

            camera.position.set(size * 4.5, size * 3.5, size * 4.5);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadedFile = file;
                fileNameDisplay.textContent = file.name;
                processBtn.disabled = false;

                // Uncheck the default card checkbox since user uploaded a file
                useDefaultCube.checked = false;

                // Track file upload
                trackEvent('file_uploaded', {
                    file_size_category: file.size < 1024*1024 ? 'small' : file.size < 10*1024*1024 ? 'medium' : 'large'
                });

                // Load preview
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadSTL(event.target.result);

                    // Update blocker preview if blocker is enabled
                    if (useBlocker.checked && useDefaultCylinder.checked) {
                        generateDefaultCylinderPreview();
                    }
                };
                reader.readAsArrayBuffer(file);

                setStatus('', '');
            }
        });

        noiseType.addEventListener('change', () => {
            const type = noiseType.value;
            if (type === 'classic') {
                noiseOptions.classList.remove('visible');
            } else {
                noiseOptions.classList.add('visible');
            }
        });

        resetViewBtn.addEventListener('click', resetView);

        // Blocker controls event handlers
        const useBlocker = document.getElementById('useBlocker');
        const blockerSection = document.getElementById('blockerSection');
        const blockerVisibilitySection = document.getElementById('blockerVisibilitySection');
        const showBlocker = document.getElementById('showBlocker');
        const useDefaultCylinder = document.getElementById('useDefaultCylinder');
        const blockerUploadSection = document.getElementById('blockerUploadSection');
        const cylinderOptions = document.getElementById('cylinderOptions');
        const blockerFileInput = document.getElementById('blockerFile');
        const cylinderRadius = document.getElementById('cylinderRadius');
        const cylinderHeight = document.getElementById('cylinderHeight');

        useBlocker.addEventListener('change', (e) => {
            blockerSection.style.display = e.target.checked ? 'block' : 'none';
            blockerVisibilitySection.style.display = e.target.checked ? 'block' : 'none';
            if (e.target.checked && useDefaultCylinder.checked) {
                generateDefaultCylinderPreview();
            } else if (!e.target.checked) {
                removeBlocker();
            }
        });

        showBlocker.addEventListener('change', (e) => {
            if (blockerMesh) {
                blockerMesh.visible = e.target.checked;
            }
        });

        const showIntersection = document.getElementById('showIntersection');
        showIntersection.addEventListener('change', (e) => {
            toggleIntersectionVisibility(e.target.checked);
        });

        useDefaultCylinder.addEventListener('change', (e) => {
            blockerUploadSection.style.display = e.target.checked ? 'none' : 'block';
            cylinderOptions.style.display = e.target.checked ? 'block' : 'none';

            if (e.target.checked) {
                generateDefaultCylinderPreview();
            } else {
                removeBlocker();
                uploadedBlockerFile = null;
            }
        });

        cylinderRadius.addEventListener('input', () => {
            if (useBlocker.checked && useDefaultCylinder.checked) {
                generateDefaultCylinderPreview();
            }
        });

        cylinderHeight.addEventListener('input', () => {
            if (useBlocker.checked && useDefaultCylinder.checked) {
                generateDefaultCylinderPreview();
            }
        });

        blockerFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                uploadedBlockerFile = file;
                document.getElementById('blockerFileName').textContent = file.name;

                // Load and preview the blocker STL
                const reader = new FileReader();
                reader.onload = (event) => {
                    loadBlockerSTL(event.target.result);
                };
                reader.readAsArrayBuffer(file);
            } else {
                uploadedBlockerFile = null;
                document.getElementById('blockerFileName').textContent = 'No blocker file selected';
                removeBlocker();
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (!processedBlob) return;

            // Track download
            trackEvent('file_downloaded', {
                file_name: processedFilename
            });

            const url = URL.createObjectURL(processedBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = processedFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Modal elements
        const confirmModal = document.getElementById('confirmModal');
        const confirmBtn = document.getElementById('confirmBtn');
        const cancelBtn = document.getElementById('cancelBtn');

        // Show confirmation modal with estimates
        async function showEstimate() {
            const usingDefaultCube = useDefaultCube.checked;
            if (!uploadedFile && !usingDefaultCube) return;

            processBtn.disabled = true;
            setStatus('Calculating estimate...', 'processing');

            const formData = new FormData();

            // Only append file if not using default cube
            if (!usingDefaultCube) {
                formData.append('file', uploadedFile);
            }

            formData.append('use_default_cube', usingDefaultCube);
            formData.append('cube_size', 20);
            formData.append('thickness', document.getElementById('thickness').value);
            formData.append('point_distance', document.getElementById('pointDistance').value);
            formData.append('seed', document.getElementById('seed').value);
            formData.append('noise_type', noiseType.value);
            formData.append('noise_scale', document.getElementById('noiseScale').value);
            formData.append('noise_octaves', document.getElementById('noiseOctaves').value);
            formData.append('noise_persistence', document.getElementById('noisePersistence').value);
            formData.append('skip_bottom', document.getElementById('skipBottom').checked);
            formData.append('skip_small_triangles', document.getElementById('skipSmallTriangles').checked);

            try {
                const response = await fetch('/api/estimate', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Estimation failed');
                }

                const result = await response.json();
                const estimates = result.estimates;

                // Populate modal with estimates
                document.getElementById('inputTriangles').textContent = estimates.input_triangles.toLocaleString();

                const outputTrianglesEl = document.getElementById('outputTriangles');
                const multiplier = (estimates.estimated_triangles / estimates.input_triangles).toFixed(1);
                outputTrianglesEl.textContent = `${estimates.estimated_triangles.toLocaleString()} (~${multiplier}x)`;

                const fileSizeEl = document.getElementById('fileSize');
                if (estimates.estimated_file_size_mb >= 1000) {
                    fileSizeEl.textContent = `${(estimates.estimated_file_size_mb / 1024).toFixed(2)} GB`;
                    fileSizeEl.className = 'estimate-value danger';
                } else if (estimates.estimated_file_size_mb >= 100) {
                    fileSizeEl.textContent = `${estimates.estimated_file_size_mb.toFixed(1)} MB`;
                    fileSizeEl.className = 'estimate-value warning';
                } else {
                    fileSizeEl.textContent = `${estimates.estimated_file_size_mb.toFixed(1)} MB`;
                    fileSizeEl.className = 'estimate-value';
                }

                const estimatedTimeEl = document.getElementById('estimatedTime');
                const timeSeconds = estimates.estimated_time_seconds;
                if (timeSeconds >= 300) {
                    estimatedTimeEl.textContent = `${(timeSeconds / 60).toFixed(1)} minutes`;
                    estimatedTimeEl.className = 'estimate-value warning';
                } else if (timeSeconds >= 60) {
                    estimatedTimeEl.textContent = `${(timeSeconds / 60).toFixed(1)} minutes`;
                    estimatedTimeEl.className = 'estimate-value';
                } else {
                    estimatedTimeEl.textContent = `${timeSeconds.toFixed(1)} seconds`;
                    estimatedTimeEl.className = 'estimate-value';
                }

                // Show warning if not feasible or very large
                const warningEl = document.getElementById('warningMessage');
                if (!result.feasible) {
                    warningEl.textContent = `⚠️ ${result.reason}`;
                    warningEl.style.display = 'block';
                } else if (estimates.estimated_triangles > 10000000) {
                    warningEl.textContent = '⚠️ This will create a very large file and may take several minutes to process.';
                    warningEl.style.display = 'block';
                } else if (estimates.estimated_file_size_mb > 500) {
                    warningEl.textContent = '⚠️ The output file will be very large and may be difficult to download.';
                    warningEl.style.display = 'block';
                } else {
                    warningEl.style.display = 'none';
                }

                // Show modal
                confirmModal.classList.add('visible');
                setStatus('', '');
            } catch (error) {
                setStatus('Error: ' + error.message, 'error');
                processBtn.disabled = false;
            }
        }

        // Process the STL file
        async function processSTL() {
            const usingDefaultCube = useDefaultCube.checked;

            processingStartTime = performance.now();
            setStatus('Processing... This may take a moment.', 'processing');

            // Track processing started
            const noiseTypeValue = noiseType.value;
            trackEvent('processing_started', {
                input_type: usingDefaultCube ? 'cube' : 'file',
                noise_type: noiseTypeValue
            });

            const formData = new FormData();

            // Only append file if not using default cube
            if (!usingDefaultCube) {
                formData.append('file', uploadedFile);
            }

            formData.append('use_default_cube', usingDefaultCube);
            formData.append('cube_size', 20);
            formData.append('thickness', document.getElementById('thickness').value);
            formData.append('point_distance', document.getElementById('pointDistance').value);
            formData.append('seed', document.getElementById('seed').value);
            formData.append('noise_type', noiseType.value);
            formData.append('noise_scale', document.getElementById('noiseScale').value);
            formData.append('noise_octaves', document.getElementById('noiseOctaves').value);
            formData.append('noise_persistence', document.getElementById('noisePersistence').value);
            formData.append('skip_bottom', document.getElementById('skipBottom').checked);
            formData.append('skip_small_triangles', document.getElementById('skipSmallTriangles').checked);

            // Blocker parameters
            if (useBlocker.checked) {
                formData.append('use_blocker', 'true');
                formData.append('blocker_algorithm', document.getElementById('blockerAlgorithm').value);
                if (useDefaultCylinder.checked) {
                    formData.append('use_default_cylinder', 'true');
                    formData.append('cylinder_radius', cylinderRadius.value);
                    formData.append('cylinder_height', cylinderHeight.value);
                } else if (uploadedBlockerFile) {
                    formData.append('blocker_file', uploadedBlockerFile);
                }
            }

            try {
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    // Check if response is JSON or HTML
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        const error = await response.json();
                        throw new Error(error.error || 'Processing failed');
                    } else {
                        // Server returned HTML (error page, timeout, or crash)
                        const text = await response.text();
                        if (response.status === 504 || response.status === 502) {
                            throw new Error('Server timeout - try using a larger point distance value or smaller file');
                        } else if (response.status === 500) {
                            throw new Error('Server error - the model may be too complex. Try a larger point distance.');
                        } else {
                            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
                        }
                    }
                }

                // Get filename from Content-Disposition header
                const contentDisposition = response.headers.get('Content-Disposition');
                let filename = 'fuzzy_output.stl';
                if (contentDisposition) {
                    const match = contentDisposition.match(/filename=(.+)/);
                    if (match) filename = match[1];
                }

                // Store the result
                processedBlob = await response.blob();
                processedFilename = filename;

                // Extract split metadata if using double_stl algorithm
                let splitMetadata = null;
                const splitIndex = response.headers.get('X-Split-Index');
                const outsideCount = response.headers.get('X-Outside-Count');
                const insideCount = response.headers.get('X-Inside-Count');

                if (splitIndex && outsideCount && insideCount) {
                    splitMetadata = {
                        splitIndex: parseInt(splitIndex),
                        outsideCount: parseInt(outsideCount),
                        insideCount: parseInt(insideCount)
                    };
                    console.log('Double STL metadata:', splitMetadata);
                }

                // Load processed model in viewer with dual-color support
                const arrayBuffer = await processedBlob.arrayBuffer();
                loadSTL(arrayBuffer, splitMetadata);

                // Enable download button
                downloadBtn.disabled = false;

                // Calculate processing time
                const processingTime = ((performance.now() - processingStartTime) / 1000).toFixed(2);
                setStatus(`Processing complete in ${processingTime}s! Click Download to save.`, 'success');

                // Track successful processing
                trackEvent('processing_success', {
                    input_type: usingDefaultCube ? 'cube' : 'file',
                    noise_type: noiseTypeValue,
                    processing_time: processingTime
                });
            } catch (error) {
                setStatus('Error: ' + error.message, 'error');

                // Track processing error
                trackEvent('processing_error', {
                    input_type: usingDefaultCube ? 'cube' : 'file',
                    noise_type: noiseTypeValue,
                    error_message: error.message
                });
            } finally {
                processBtn.disabled = false;
            }
        }

        // Process button shows estimate first
        processBtn.addEventListener('click', showEstimate);

        // Confirm button starts actual processing
        confirmBtn.addEventListener('click', () => {
            confirmModal.classList.remove('visible');
            processSTL();
        });

        // Cancel button closes modal
        cancelBtn.addEventListener('click', () => {
            confirmModal.classList.remove('visible');
            processBtn.disabled = false;
        });

        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status';
            if (type) {
                statusDiv.classList.add(type);
            }
        }

        // Initialize
        initViewer();

        // Load default object on page load
        if (useDefaultCube.checked) {
            generateDefaultObjectPreview();
        }
    </script>
</body>
</html>
